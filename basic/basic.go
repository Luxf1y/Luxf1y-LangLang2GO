package main

import "fmt"

func GetData() (int, int) {
	return 100, 200
}

// 如果b为真，btoi返回1；如果为假，btoi返回0
func btoi(b bool) int {
	if b {
		fmt.Println("判断式为真")
		return 1
	}
	fmt.Println("判断式为假")
	return 0
}

//声明全局变量
var c int

func main() {

	//Part1
	/*	var attack = 40
		var defence = 20
		var damageRate float32 = 0.17
		var damage = float32(attack-defence) * damageRate
		fmt.Println(damage)//damage 变量的右值是一个复杂的表达式，整个过程既有 attack 和 defence 的运算还有强制类型转换。强制类型转换会在后面的章节中介绍。
	*/
	//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Part2
	/*	// 声明 hp 变量
		var hp int
		// 再次声明并赋值
		hp := 10*/
	/*	编译报错如下：
		no new variables on left side of :=*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part3
	/*	conn1, err1 := net.Dial("tcp","127.0.0.1:8080")//此为短变量声明，短变量声明的形式在开发中的例子较多

		var conn net.Conn//此为正常声明
		var err error
		conn, err = net.Dial("tcp", "127.0.0.1:8080")

		fmt.Println(conn)//golang中Print和Println的小区基本一致，但是后者在输出后会进行换行
		fmt.Println(err)

		fmt.Println(conn1)
		fmt.Println(err1)*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part4
	/*	var a int = 100//使用 Go 的“多重赋值”特性，可以轻松完成变量交换的任务
		var b int = 200
		b, a = a, b
		fmt.Println(a, b)
	*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part5
	/*	//在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。
		//匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。
		//匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。
		a, _ := GetData()
		_, b := GetData()
		fmt.Println(a, b)
	*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part6
	/*
		//声明局部变量 a 和 b 并赋值
		var a int = 3
		var b int = 4
		//声明局部变量 c 并计算 a 和 b 的和
		c :=a+b
		fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
	*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part7
	/*	var f float32 = 1678111//一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型
		fmt.Println(f == f+1)    // "true"!
		fmt.Printf("%.2f\n", math.Pi)//用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part8
	/*	var b=10 //bool型
		btoi(b==10)*/

	/*var n bool//Go语言中不允许将整型强制转换为布尔型
	fmt.Println(int(n) * 2) //编译错误，输出如下：cannot convert n (type bool) to type int
	*/
	//--------------------------------------------------------------------------------------------------------------------------------------------------
	//Part9
	/*	var str = "C语言中文网\nGo语言教程"
		fmt.Println(str)*/
	/*
		\n：换行符
		\r：回车符
		\t：tab 键
		\u 或 \U：Unicode 字符
		\\：反斜杠自身
	*/

	/*	s := "hel" + "lo,"
		s += "world!"
		fmt.Println(s) //输出 “hello, world!”

		str := "Beginning of the string " +
			"second part of the string"
		fmt.Println(str)//两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。*/

	const str = `第一行
第二行
第三行
\r\n
`
	fmt.Println(str) //反引号`，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。 在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。
	fmt.Println()
}
